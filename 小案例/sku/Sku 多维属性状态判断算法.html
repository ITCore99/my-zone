<!DOCTYPE html>
<!-- saved from url=(0116)https://keelii.com/2016/12/22/sku-multi-dimensional-attributes-state-algorithm/#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0 -->
<html class="no-js" lang="zh-CN" data-blockbyte-bs-uid="74543"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <title>Sku 多维属性状态判断算法</title>
    <meta name="description" content="__ you don&#39;t know yet">
    <meta name="keywords" content="">
    <meta name="author" content="keelii">
    <meta name="generator" content="Hugo 0.54.0">

    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    

    <link rel="canonical" href="https://keelii.com/2016/12/22/sku-multi-dimensional-attributes-state-algorithm/">
    <link href="https://keelii.com/favicon.ico" rel="icon">
    <link rel="apple-touch-icon" sizes="57x57" href="https://keelii.com/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="https://keelii.com/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="https://keelii.com/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="https://keelii.com/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="https://keelii.com/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="https://keelii.com/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="https://keelii.com/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="https://keelii.com/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="https://keelii.com/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192" href="https://keelii.com/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://keelii.com/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="https://keelii.com/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://keelii.com/favicon-16x16.png">
    <link rel="manifest" href="https://keelii.com/manifest.json">
    <meta name="msapplication-TileColor" content="##f7f7f7">
    <meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
    <meta name="theme-color" content="##f7f7f7">

    <link href="https://keelii.com/atom.xml" rel="alternate" type="application/rss+xml" title="臨池不輟">

    
    <link href="./Sku 多维属性状态判断算法_files/main.min.css" rel="stylesheet" type="text/css">

    
    
    <script type="text/javascript" async="" src="./Sku 多维属性状态判断算法_files/analytics.js.下载"></script><script async="" src="./Sku 多维属性状态判断算法_files/js"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-79264835-1');
    </script>

<script src="https://keelii-blog.disqus.com/embed.js" data-timestamp="1592708679591"></script><style class="blockbyte-bs-style" data-name="content">body>div#blockbyte-bs-indicator>div{opacity:0;pointer-events:none}body>iframe#blockbyte-bs-sidebar.blockbyte-bs-visible,body>iframe#blockbyte-bs-overlay.blockbyte-bs-visible{opacity:1;pointer-events:auto}body.blockbyte-bs-noscroll{overflow:hidden !important}body>div#blockbyte-bs-indicator>div{position:absolute;transform:translate3d(-40px, 0, 0);top:0;left:0;width:40px !important;height:100%;background:rgba(0,0,0,0.5);border-radius:0 10px 10px 0;transition:opacity 0.3s, transform 0.3s;z-index:2}body>div#blockbyte-bs-indicator>div>span{-webkit-mask:no-repeat center/32px;-webkit-mask-image:url(chrome-extension://jdbnofccmhefkmjbkkdkfiicjkgofkdh/img/icon-bookmark.svg);background-color:#ffffff;position:absolute;display:block;top:0;left:0;width:100%;height:100%}body>div#blockbyte-bs-indicator[data-pos='right']{left:auto;right:0}body>div#blockbyte-bs-indicator[data-pos='right']>div{transform:translate3d(40px, 0, 0);left:auto;right:0;border-radius:10px 0 0 10px}body>div#blockbyte-bs-indicator.blockbyte-bs-fullHeight>div{border-radius:0}body>div#blockbyte-bs-indicator.blockbyte-bs-hover>div{transform:translate3d(0, 0, 0);opacity:1}body>div#blockbyte-bs-indicator[data-pos='left'].blockbyte-bs-has-lsb{height:100% !important;top:0 !important}body>div#blockbyte-bs-indicator[data-pos='left'].blockbyte-bs-has-lsb>div{background:transparent}body>div#blockbyte-bs-indicator[data-pos='left'].blockbyte-bs-has-lsb>div>span{-webkit-mask-position-y:20px}body>iframe#blockbyte-bs-sidebar{width:350px;max-width:none;height:0;z-index:2147483646;background-color:rgba(255,255,255,0.8) !important;border:none;display:block !important;transform:translate3d(-350px, 0, 0);transition:width 0s 0.3s, height 0s 0.3s, opacity 0.3s, transform 0.3s}body>iframe#blockbyte-bs-sidebar[data-pos='right']{left:auto;right:0;transform:translate3d(350px, 0, 0)}body>iframe#blockbyte-bs-sidebar.blockbyte-bs-visible{width:calc(100% + 350px);height:100%;transform:translate3d(0, 0, 0);transition:opacity 0.3s, transform 0.3s}body>iframe#blockbyte-bs-sidebar.blockbyte-bs-hideMask{background:none !important}body>iframe#blockbyte-bs-sidebar.blockbyte-bs-hideMask:not(.blockbyte-bs-hover){width:calc(350px + 50px)}body>iframe#blockbyte-bs-overlay{width:100%;max-width:none;height:100%;z-index:2147483647;border:none;background:rgba(0,0,0,0.5) !important;transition:opacity 0.3s}
</style><script src="./Sku 多维属性状态判断算法_files/1f2cf4f473fe9a5b05.js.下载"></script><script type="text/javascript" src="./Sku 多维属性状态判断算法_files/int.js.下载"></script><script type="text/javascript" src="./Sku 多维属性状态判断算法_files/api"></script></head>
<body>
    <div class="container">

<script>
    (function(window, document) {
        window.changeTheme = function() {
            var el = document.getElementById('dark-theme')
            var dark = localStorage.getItem('dark')
            if (dark === 'true') {
                document.body.classList.add('dark')
                if (el) el.checked = true
            } else {
                document.body.classList.remove('dark')
                if (el) el.checked = false
            }
        }
        changeTheme()
    })(window, document);
</script>

<div id="main">
    <div id="content" class="typo null">
        <div style="padding-top:0;">
            <article class="hentry" role="article">
                <header>
                    <h1 class="entry-title">sku 多维属性状态判断算法</h1>
                    <p class="meta">
                        <time class="entry-date" datetime="2016-12-22 15:55:52">
                            <span class="date">2016-12-22</span>
                            <span class="time">15:55 PM</span>
                            · <a href="https://keelii.com/">首页</a>
                        </time>
                    </p>
                </header>

                <div class="entry-content">

<h2 id="问题描述">问题描述</h2>

<p>这个问题来源于选择商品属性的场景。比如我们买衣服、鞋子这类物件，一般都需要我们选择合适的颜色、尺码等属性</p>

<p><img src="./Sku 多维属性状态判断算法_files/585b8939Na04471ff.png" alt="color_size"></p>

<p>先了解一下 sku 的学术概念吧</p>

<blockquote>
<p>最小库存管理单元（Stock Keeping Unit, SKU）是一个会计学名词，定义为库存管理中的最小可用单元，例如纺织品中一个SKU通常表示规格、颜色、款式，而在连锁零售门店中有时称单品为一个SKU。最小库存管理单元可以区分不同商品销售的最小单元，是科学管理商品的采购、销售、物流和财务管理以及POS和MIS系统的数据统计的需求，通常对应一个管理信息系统的编码。 —— form wikipedia <a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E5%AD%98%E8%B4%A7%E5%8D%95%E4%BD%8D">最小存货单位</a></p>
</blockquote>

<p>简单的结合上面的实例来说： sku 就是你上购物网站买到的最终商品，对应的上图中已选择的属性是：颜色 <strong>黑色</strong> - 尺码 <strong>37</strong></p>

<p>我先看看后端数据结构一般是这样的，一个线性数组，每个元素是一个描述当前 sku 的 map，比如：</p>

<pre><code class="language-json hljs">[
   { <span class="hljs-attr">"颜色"</span>: <span class="hljs-string">"红"</span>, <span class="hljs-attr">"尺码"</span>: <span class="hljs-string">"大"</span>, <span class="hljs-attr">"型号"</span>: <span class="hljs-string">"A"</span>, <span class="hljs-attr">"skuId"</span>: <span class="hljs-string">"3158054"</span> },
   { <span class="hljs-attr">"颜色"</span>: <span class="hljs-string">"白"</span>, <span class="hljs-attr">"尺码"</span>: <span class="hljs-string">"中"</span>, <span class="hljs-attr">"型号"</span>: <span class="hljs-string">"B"</span>, <span class="hljs-attr">"skuId"</span>: <span class="hljs-string">"3133859"</span> },
   { <span class="hljs-attr">"颜色"</span>: <span class="hljs-string">"蓝"</span>, <span class="hljs-attr">"尺码"</span>: <span class="hljs-string">"小"</span>, <span class="hljs-attr">"型号"</span>: <span class="hljs-string">"C"</span>, <span class="hljs-attr">"skuId"</span>: <span class="hljs-string">"3516833"</span> }
]
</code></pre>

<p>前端展示的时候显然需要 group 一下，按不同的属性分组，目的就是让用户按属性的维度去选择，group 后的数据大概是这样的：</p>

<pre><code class="language-json hljs">{
    <span class="hljs-attr">"颜色"</span>: [<span class="hljs-string">"红"</span>, <span class="hljs-string">"白"</span>, <span class="hljs-string">"蓝"</span>],
    <span class="hljs-attr">"尺码"</span>: [<span class="hljs-string">"大"</span>, <span class="hljs-string">"中"</span>, <span class="hljs-string">"小"</span>],
    <span class="hljs-attr">"型号"</span>: [<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>]
}
</code></pre>

<p>对应的在网页上大概是这样的 UI</p>

<p><img src="./Sku 多维属性状态判断算法_files/585b9042N5e527489.png" alt="ui_demo"></p>

<p>这个时候，就会有一个问题，这些元子属性能组成的集合（用户的选择路径） <strong>远远大于</strong> 真正可以组成的集合，比如上面的属性集合可以组合成一个 <a href="https://zh.wikipedia.org/wiki/%E7%AC%9B%E5%8D%A1%E5%84%BF%E7%A7%AF">笛卡尔积</a>，即。可以组合成以下序列：</p>

<pre><code class="language-javascript hljs">[
    [<span class="hljs-string">"红"</span>, <span class="hljs-string">"大"</span>, <span class="hljs-string">"A"</span>],    <span class="hljs-comment">// ✔</span>
    [<span class="hljs-string">"红"</span>, <span class="hljs-string">"大"</span>, <span class="hljs-string">"B"</span>],
    [<span class="hljs-string">"红"</span>, <span class="hljs-string">"大"</span>, <span class="hljs-string">"C"</span>],
    [<span class="hljs-string">"红"</span>, <span class="hljs-string">"中"</span>, <span class="hljs-string">"A"</span>],
    [<span class="hljs-string">"红"</span>, <span class="hljs-string">"中"</span>, <span class="hljs-string">"B"</span>],
    [<span class="hljs-string">"红"</span>, <span class="hljs-string">"中"</span>, <span class="hljs-string">"C"</span>],
    [<span class="hljs-string">"红"</span>, <span class="hljs-string">"小"</span>, <span class="hljs-string">"A"</span>],
    [<span class="hljs-string">"红"</span>, <span class="hljs-string">"小"</span>, <span class="hljs-string">"B"</span>],
    [<span class="hljs-string">"红"</span>, <span class="hljs-string">"小"</span>, <span class="hljs-string">"C"</span>],
    [<span class="hljs-string">"白"</span>, <span class="hljs-string">"大"</span>, <span class="hljs-string">"A"</span>],
    [<span class="hljs-string">"白"</span>, <span class="hljs-string">"大"</span>, <span class="hljs-string">"B"</span>],
    [<span class="hljs-string">"白"</span>, <span class="hljs-string">"大"</span>, <span class="hljs-string">"C"</span>],
    [<span class="hljs-string">"白"</span>, <span class="hljs-string">"中"</span>, <span class="hljs-string">"A"</span>],
    [<span class="hljs-string">"白"</span>, <span class="hljs-string">"中"</span>, <span class="hljs-string">"B"</span>],    <span class="hljs-comment">// ✔</span>
    [<span class="hljs-string">"白"</span>, <span class="hljs-string">"中"</span>, <span class="hljs-string">"C"</span>],
    [<span class="hljs-string">"白"</span>, <span class="hljs-string">"小"</span>, <span class="hljs-string">"A"</span>],
    [<span class="hljs-string">"白"</span>, <span class="hljs-string">"小"</span>, <span class="hljs-string">"B"</span>],
    [<span class="hljs-string">"白"</span>, <span class="hljs-string">"小"</span>, <span class="hljs-string">"C"</span>],
    [<span class="hljs-string">"蓝"</span>, <span class="hljs-string">"大"</span>, <span class="hljs-string">"A"</span>],
    [<span class="hljs-string">"蓝"</span>, <span class="hljs-string">"大"</span>, <span class="hljs-string">"B"</span>],
    [<span class="hljs-string">"蓝"</span>, <span class="hljs-string">"大"</span>, <span class="hljs-string">"C"</span>],
    [<span class="hljs-string">"蓝"</span>, <span class="hljs-string">"中"</span>, <span class="hljs-string">"A"</span>],
    [<span class="hljs-string">"蓝"</span>, <span class="hljs-string">"中"</span>, <span class="hljs-string">"B"</span>],
    [<span class="hljs-string">"蓝"</span>, <span class="hljs-string">"中"</span>, <span class="hljs-string">"C"</span>],
    [<span class="hljs-string">"蓝"</span>, <span class="hljs-string">"小"</span>, <span class="hljs-string">"A"</span>],
    [<span class="hljs-string">"蓝"</span>, <span class="hljs-string">"小"</span>, <span class="hljs-string">"B"</span>],
    [<span class="hljs-string">"蓝"</span>, <span class="hljs-string">"小"</span>, <span class="hljs-string">"C"</span>]     <span class="hljs-comment">// ✔</span>
]
</code></pre>

<p>根据公式可以知道，<strong>一个由 3 个元素，每个元素是有 3 个元素的子集构成的集合，能组成的笛卡尔积一共有 3 的 3 次幂，也就是 27 种</strong>，然而源数据只可以形成 3 种组合</p>

<p>这种情况下最好能提前判断出来不可选的路径并置灰，告诉用户，否则会造成误解</p>

<h2 id="确定规则">确定规则</h2>

<p>看下图，如果我们定义红色为当前选中的商品的属性，即当前选中商品为 <code>红-大-A</code>，这个时候如何确认其它非已选属性是否可以组成可选路径？</p>

<p><img src="./Sku 多维属性状态判断算法_files/585b9636Nc5d3efd4.png" alt="ui_selected"></p>

<p><strong>规则是这样的：</strong> 假设当前用户想选 <code>白-大-A</code>，刚好这个选择路径是不存在的，那么我们就把 <code>白</code> 置灰</p>

<p><img src="./Sku 多维属性状态判断算法_files/585b9717Nf53b5e3e.png" alt="ui_selected_disabled"></p>

<p>以此类推，如果要确认 <code>蓝</code> 属性是否可用，需要查找 <code>蓝-大-A</code> 路径是否存在</p>

<p>…</p>

<h2 id="解决方法">解决方法</h2>

<p>根据上面的逻辑代码实现思路就有了：</p>

<ol>
<li>遍历所有非已选元素：<code>"白", "蓝", "中", "小", "B", "C"</code>

<ol>
<li>遍历所有属性行： <code>"颜色", "尺码", "型号"</code>

<ol>
<li>取： a) 当前元素 b) 非当前元素所在的其它属性已选元素，形成一个路径</li>
<li>判断此路径是否存在，如果不存在将当前元素置灰</li>
</ol></li>
</ol></li>
</ol>

<p>看来问题似乎已经解决了，然而 …</p>

<p>我们忽略了一个非常重要的问题：上例中虽然 <code>白</code> 元素置灰，但是实际上 <code>白</code> 是可以被点击的！因为用户可以选择 <code>白-中-B</code> 路径</p>

<p>如果用户点击了 <code>白</code> 情况就变得复杂了很多，我们假设用户 <strong>只选择了一个</strong>元素 <code>白</code>，此时如何判断其它未选元素是否可选？</p>

<p><img src="./Sku 多维属性状态判断算法_files/585b9c36N668cd64b.png" alt="ui_selected_one"></p>

<p>即：如何确定 <code>"大", "中", "小", "A", "B", "C"</code> 需要置灰？ 注意我们并不需要确认 <code>"红"，"蓝"</code> 是否可选，因为属性里面的元素都是 <strong>单选</strong>，当前的属性里任何元素都可选的</p>

<h3 id="缩小问题规模">缩小问题规模</h3>

<p>我们先 <strong>缩小问题范围</strong>：当前情况下（只有一个 <code>白</code> 已选）如何确定尺码 <code>"大"</code> 需要置灰？ 你可能会想到根据我们之间的逻辑，需要分别查找：</p>

<ul>
<li>白 - 大 - A</li>
<li>白 - 大 - B</li>
<li>白 - 大 - C</li>
</ul>

<p>他们都不存在的时候把尺码 <code>大</code> 置灰，问题似乎也可以解决。其实这样是不对的，因为 <strong>型号没有被选择过</strong>，所以只需要知道 <code>白-大</code>是否可选即可</p>

<p>同时还有一个问题，如果已选的个数不确定而且维度可以增加到不确定呢？</p>

<p><img src="./Sku 多维属性状态判断算法_files/585ba187N9bf3b55d.png" alt="ui_muli-attr"></p>

<p>这种情况下如果还按之前的算法，即使实现也非常复杂。这时候就要考虑换一种思维方式</p>

<h3 id="调整思路">调整思路</h3>

<p>之前我们都是反向思考，找出不可选应该置灰的元素。我们现在正向的考虑，如何确定属性是否可选。而且多维的情况下用户可以跳着选。比如：用户选了两个元素 <code>白，B</code></p>

<p><img src="./Sku 多维属性状态判断算法_files/585ba3f5Nc07d80f6.png" alt="ui_muli-attr_two">  <em>图1</em></p>

<p>我们再回过头来看下 <strong>原始存在的数据</strong></p>

<pre><code class="language-javascript hljs">[
   { <span class="hljs-string">"颜色"</span>: <span class="hljs-string">"红"</span>, <span class="hljs-string">"尺码"</span>: <span class="hljs-string">"大"</span>, <span class="hljs-string">"型号"</span>: <span class="hljs-string">"A"</span>, <span class="hljs-string">"skuId"</span>: <span class="hljs-string">"3158054"</span> },
   { <span class="hljs-string">"颜色"</span>: <span class="hljs-string">"白"</span>, <span class="hljs-string">"尺码"</span>: <span class="hljs-string">"中"</span>, <span class="hljs-string">"型号"</span>: <span class="hljs-string">"B"</span>, <span class="hljs-string">"skuId"</span>: <span class="hljs-string">"3133859"</span> },
   { <span class="hljs-string">"颜色"</span>: <span class="hljs-string">"蓝"</span>, <span class="hljs-string">"尺码"</span>: <span class="hljs-string">"小"</span>, <span class="hljs-string">"型号"</span>: <span class="hljs-string">"C"</span>, <span class="hljs-string">"skuId"</span>: <span class="hljs-string">"3516833"</span> }
]
<span class="hljs-comment">// 即</span>
[
   [ <span class="hljs-string">"红"</span>, <span class="hljs-string">"大"</span>, <span class="hljs-string">"A"</span> ],   <span class="hljs-comment">// 存在</span>
   [ <span class="hljs-string">"白"</span>, <span class="hljs-string">"中"</span>, <span class="hljs-string">"B"</span> ],   <span class="hljs-comment">// 存在</span>
   [ <span class="hljs-string">"蓝"</span>, <span class="hljs-string">"小"</span>, <span class="hljs-string">"C"</span> ]    <span class="hljs-comment">// 存在</span>
]
</code></pre>

<p>显然：如果第一条数据 <code>"红", "大", "A"</code> 存在，那么下面这些子组合 <strong>肯定都存在</strong>：</p>

<ul>
<li>红</li>
<li>大</li>
<li>A</li>
<li>红 - 大</li>
<li>红 - A</li>
<li>大 - A</li>
<li>红 - 大 - A</li>
</ul>

<p>同理：如果第二条数据 <code>"白", "中", "B"</code> 存在，那么下面这些子组合 <strong>肯定都存在</strong>：</p>

<ul>
<li>白</li>
<li>中</li>
<li>B</li>
<li>白 - 中</li>
<li>白 - B</li>
<li>中 - B</li>
<li>白 - 中 - B</li>
</ul>

<p>…</p>

<p>我们提前把 <strong>所有存在的路径中的子组合</strong> 算出来，算法上叫取集合所有子集，数学上叫 <a href="https://zh.wikipedia.org/wiki/%E5%86%AA%E9%9B%86">幂集</a>， 形成一个所有存在的路径表，算法如下：</p>

<pre><code class="language-javascript hljs"><span class="hljs-comment">/**
 * 取得集合的所有子集「幂集」
 arr = [1,2,3]

     i = 0, ps = [[]]:
         j = 0; j &lt; ps.length =&gt; j &lt; 1:
             i=0, j=0 ps.push(ps[0].concat(arr[0])) =&gt; ps.push([].concat(1)) =&gt; [1]
                      ps = [[], [1]]

     i = 1, ps = [[], [1]] :
         j = 0; j &lt; ps.length =&gt; j &lt; 2
             i=1, j=0 ps.push(ps[0].concat(arr[1])) =&gt; ps.push([].concat(2))  =&gt; [2]
             i=1, j=1 ps.push(ps[1].concat(arr[1])) =&gt; ps.push([1].concat(2)) =&gt; [1,2]
                      ps = [[], [1], [2], [1,2]]

     i = 2, ps = [[], [1], [2], [1,2]]
         j = 0; j &lt; ps.length =&gt; j &lt; 4
             i=2, j=0 ps.push(ps[0].concat(arr[2])) =&gt; ps.push([3])    =&gt; [3]
             i=2, j=1 ps.push(ps[1].concat(arr[2])) =&gt; ps.push([1, 3]) =&gt; [1, 3]
             i=2, j=2 ps.push(ps[2].concat(arr[2])) =&gt; ps.push([2, 3]) =&gt; [2, 3]
             i=2, j=3 ps.push(ps[3].concat(arr[2])) =&gt; ps.push([2, 3]) =&gt; [1, 2, 3]
                      ps = [[], [1], [2], [1,2], [3], [1, 3], [2, 3], [1, 2, 3]]
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">powerset</span>(<span class="hljs-params">arr</span>) </span>{
    <span class="hljs-keyword">var</span> ps = [[]];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i &lt; arr.length; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>, len = ps.length; j &lt; len; j++) {
            ps.push(ps[j].concat(arr[i]));
        }
    }
    <span class="hljs-keyword">return</span> ps;
}
</code></pre>

<p>有了这个存在的子集集合，再回头看 <em>图1</em> 举例：</p>

<p><img src="./Sku 多维属性状态判断算法_files/585ba3f5Nc07d80f6.png" alt="ui_muli-attr_two">  <em>图1</em></p>

<ul>
<li>如何确定 <code>红</code> 可选？ 只需要确定 <code>红-B</code> 可选</li>
<li>如何确定 <code>中</code> 可选？ 需要确定 <code>白-中-B</code> 可选</li>
<li>如何确定 <code>2G</code> 可选？ 需要确定 <code>白-B-2G</code> 可选</li>
</ul>

<p>算法描述如下：</p>

<ol>
<li>遍历所有非已选元素

<ol>
<li>遍历所有属性行

<ol>
<li>取： a) 当前元素 b) 非当前元素所在的其它属性已选元素（如果当前属性中没已选元素，则跳过），形成一个路径</li>
<li>判断此路径是否存在（在所有存在的路径表中查询），如果不存在将当前元素置灰</li>
</ol></li>
</ol></li>
</ol>

<p>以最开始的后端数据为例，生成的所有可选路径表如下：
注意路径用分割符号「-」分开是为了查找路径时方便，不用遍历</p>

<pre><code class="language-json hljs">{
    <span class="hljs-attr">""</span>: {
        <span class="hljs-attr">"skus"</span>: [<span class="hljs-string">"3158054"</span>, <span class="hljs-string">"3133859"</span>, <span class="hljs-string">"3516833"</span>]
    },
    <span class="hljs-attr">"红"</span>: {
        <span class="hljs-attr">"skus"</span>: [<span class="hljs-string">"3158054"</span>]
    },
    <span class="hljs-attr">"大"</span>: {
        <span class="hljs-attr">"skus"</span>: [<span class="hljs-string">"3158054"</span>]
    },
    <span class="hljs-attr">"红-大"</span>: {
        <span class="hljs-attr">"skus"</span>: [<span class="hljs-string">"3158054"</span>]
    },
    <span class="hljs-attr">"A"</span>: {
        <span class="hljs-attr">"skus"</span>: [<span class="hljs-string">"3158054"</span>]
    },
    <span class="hljs-attr">"红-A"</span>: {
        <span class="hljs-attr">"skus"</span>: [<span class="hljs-string">"3158054"</span>]
    },
    <span class="hljs-attr">"大-A"</span>: {
        <span class="hljs-attr">"skus"</span>: [<span class="hljs-string">"3158054"</span>]
    },
    <span class="hljs-attr">"红-大-A"</span>: {
        <span class="hljs-attr">"skus"</span>: [<span class="hljs-string">"3158054"</span>]
    },
    <span class="hljs-attr">"白"</span>: {
        <span class="hljs-attr">"skus"</span>: [<span class="hljs-string">"3133859"</span>]
    },
    <span class="hljs-attr">"中"</span>: {
        <span class="hljs-attr">"skus"</span>: [<span class="hljs-string">"3133859"</span>]
    },
    <span class="hljs-attr">"白-中"</span>: {
        <span class="hljs-attr">"skus"</span>: [<span class="hljs-string">"3133859"</span>]
    },
    <span class="hljs-attr">"B"</span>: {
        <span class="hljs-attr">"skus"</span>: [<span class="hljs-string">"3133859"</span>]
    },
    <span class="hljs-attr">"白-B"</span>: {
        <span class="hljs-attr">"skus"</span>: [<span class="hljs-string">"3133859"</span>]
    },
    <span class="hljs-attr">"中-B"</span>: {
        <span class="hljs-attr">"skus"</span>: [<span class="hljs-string">"3133859"</span>]
    },
    <span class="hljs-attr">"白-中-B"</span>: {
        <span class="hljs-attr">"skus"</span>: [<span class="hljs-string">"3133859"</span>]
    },
    <span class="hljs-attr">"蓝"</span>: {
        <span class="hljs-attr">"skus"</span>: [<span class="hljs-string">"3516833"</span>]
    },
    <span class="hljs-attr">"小"</span>: {
        <span class="hljs-attr">"skus"</span>: [<span class="hljs-string">"3516833"</span>]
    },
    <span class="hljs-attr">"蓝-小"</span>: {
        <span class="hljs-attr">"skus"</span>: [<span class="hljs-string">"3516833"</span>]
    },
    <span class="hljs-attr">"C"</span>: {
        <span class="hljs-attr">"skus"</span>: [<span class="hljs-string">"3516833"</span>]
    },
    <span class="hljs-attr">"蓝-C"</span>: {
        <span class="hljs-attr">"skus"</span>: [<span class="hljs-string">"3516833"</span>]
    },
    <span class="hljs-attr">"小-C"</span>: {
        <span class="hljs-attr">"skus"</span>: [<span class="hljs-string">"3516833"</span>]
    },
    <span class="hljs-attr">"蓝-小-C"</span>: {
        <span class="hljs-attr">"skus"</span>: [<span class="hljs-string">"3516833"</span>]
    }
}
</code></pre>

<p>为了更清楚的说明这个算法，再上一张图来解释下吧：</p>

<p><img src="./Sku 多维属性状态判断算法_files/58620377Nde9640c3.jpg" alt="color-size-sel"></p>

<p>所以根据上面的逻辑得出，计算状态后的界面应该是这样的：</p>

<p><img src="./Sku 多维属性状态判断算法_files/5862159bN7d072d5f.png" alt="color_size_with_state"></p>

<p>现在这种情况下如果用户点击 尺码 <code>中</code> 应该怎么交互呢？</p>

<h3 id="优化体验">优化体验</h3>

<p>因为当前情况下路径 <code>红-中-A</code> 并不存在，如果点击 <code>中</code>，那么除了尺码 <code>中</code> 之外其它的属性中 <strong>至少有一个</strong> 属性和 <code>中</code> 的路径搭配是不存在的</p>

<p>交互方面需求是：如果不存在就高亮当前属性行，使用户必须选择到可以和 <code>中</code> 组合存在的属性。而且用户之间选择过的属性要做一次缓存</p>

<p>所以当点击不存在的属性时交互流程是这样的：</p>

<ol>
<li>无论当前属性存不存在，先高亮（选中）当前属性</li>
<li>清除其它所有已选属性</li>
<li>更新当前状态（只选当前属性）下的其它属性可选状态</li>
<li>遍历非当前属性行的其它属性查找对应的在缓存中的已选属性</li>
<li>如果缓存中对应的属性存在（可选），则默认选中缓存属性并 <strong>再次更新</strong> 其它可选状态。不存在，则高亮当前属性行（深色背景）</li>
</ol>

<p>这个过程的流程图大概是这样的，点进不存在的属性就会进入「单选流程」</p>

<p><img src="./Sku 多维属性状态判断算法_files/58653ae6Nf0a3ed56.png" alt="select_diag"></p>

<p>假设后端数据是这样的：</p>

<pre><code class="language-javascript hljs">[
   { <span class="hljs-string">"颜色"</span>: <span class="hljs-string">"红"</span>, <span class="hljs-string">"尺码"</span>: <span class="hljs-string">"大"</span>, <span class="hljs-string">"型号"</span>: <span class="hljs-string">"A"</span>, <span class="hljs-string">"skuId"</span>: <span class="hljs-string">"3158054"</span> },
   { <span class="hljs-string">"颜色"</span>: <span class="hljs-string">"白"</span>, <span class="hljs-string">"尺码"</span>: <span class="hljs-string">"大"</span>, <span class="hljs-string">"型号"</span>: <span class="hljs-string">"A"</span>, <span class="hljs-string">"skuId"</span>: <span class="hljs-string">"3158054"</span> }, <span class="hljs-comment">// 多加了一条</span>
   { <span class="hljs-string">"颜色"</span>: <span class="hljs-string">"白"</span>, <span class="hljs-string">"尺码"</span>: <span class="hljs-string">"中"</span>, <span class="hljs-string">"型号"</span>: <span class="hljs-string">"B"</span>, <span class="hljs-string">"skuId"</span>: <span class="hljs-string">"3133859"</span> },
   { <span class="hljs-string">"颜色"</span>: <span class="hljs-string">"蓝"</span>, <span class="hljs-string">"尺码"</span>: <span class="hljs-string">"小"</span>, <span class="hljs-string">"型号"</span>: <span class="hljs-string">"C"</span>, <span class="hljs-string">"skuId"</span>: <span class="hljs-string">"3516833"</span> }
]
</code></pre>

<p>当前选中状态是：<code>白-大-A</code></p>

<p><img src="./Sku 多维属性状态判断算法_files/58624212Ne7f43d1f.png" alt="color_size_demo"></p>

<p>如果用户点击 <code>中</code>。这个时候 <code>白-中</code> 是存在的，但是 <code>中-A</code> 并不存在，所以保留颜色 <code>白</code>，高亮型号属性行：</p>

<p><img src="./Sku 多维属性状态判断算法_files/58624270N59d19a52.png" alt="color_size_demo_width_hl"></p>

<p>由此可见和 <code>白-中</code> 能搭配存在型号只有 <code>B</code>，而缓存的作用就是为了少让用户选一次颜色 <code>白</code></p>

<p>到这里，基本上主要的功能就实现了。比如库存逻辑处理方式也和不存属性一样，就不再赘述。唯一需要注意的地方是求幂集的复杂度问题</p>

<h2 id="算法复杂度">算法复杂度</h2>

<p>幂集算法的时间复杂度是 <code>O(2^n)</code>，也就是说每条数据上面的属性（维度）越多，复杂度越高。sku 数据的多少并不重要，因为是常数级的线性增长，而维度是指数级的增长</p>

<pre><code class="hljs ruby">{<span class="hljs-number">1</span>}       <span class="hljs-number">2</span>^<span class="hljs-number">1</span> = <span class="hljs-number">2</span>
=&gt; {},{<span class="hljs-number">1</span>}
{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>}     <span class="hljs-number">2</span>^<span class="hljs-number">2</span> = <span class="hljs-number">4</span>
=&gt; {},{<span class="hljs-number">1</span>},{<span class="hljs-number">2</span>},{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>}
{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>}   <span class="hljs-number">2</span>^<span class="hljs-number">3</span> = <span class="hljs-number">8</span>
=&gt; {},{<span class="hljs-number">1</span>},{<span class="hljs-number">2</span>},{<span class="hljs-number">3</span>},{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>},{<span class="hljs-number">1</span>,<span class="hljs-number">3</span>},{<span class="hljs-number">2</span>,<span class="hljs-number">3</span>},{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>}
...
</code></pre>

<p><img src="./Sku 多维属性状态判断算法_files/5864aa23N95cea203.png" alt="powerset_test"></p>

<p>在 chrome 里面简单跑了几个用例，可见这个算法非常低效，如果要使用这个算法，必须控制维度在合理范围内，而且不仅仅算法时间复杂度很高，生成最后的路径表也会非常大，相应的占用内存也很高。</p>

<p>举个例子：如果有一个 10 维的 sku，那么最终生成的路径表会有 2^10 个（1024） key/value</p>

<p>最终 demo 可以查看这个：
<a href="http://codepen.io/keelii/pen/RoOzgb">sku 多维属性状态判断</a></p>

<p>相关资料：
<a href="http://git.shepherdwind.com/sku-search-algorithm.html">sku组合查询算法探索</a></p>
</div>
                <footer>
                    <p class="meta" style="display:none">
                        <span class="byline author vcard">Posted</span>
                        
                        <span class="span">on</span>
                        <span class="categories">
                            
                            
                            <a class="category 0|2" href="https://keelii.com/categories/jd">jd</a>,
                            
                            <a class="category 1|2" href="https://keelii.com/categories/algorithm">algorithm</a>
                            
                        </span>
                        
                    </p>
                    
                    
                    <p class="meta salign">
                        
                        <span class="basic-alignment left">
                            « <a href="https://keelii.com/2016/11/21/trimpath-template-engine/" title="Previous Post: TrimPath 模板引擎使用指南">TrimPath 模板引擎使用指南</a>
                        </span>
                        

                        
                        <span class="basic-alignment right">
                            <a href="https://keelii.com/2017/02/19/basic-operations-of-relation-algebra/" title="Nextious Post: 关系代数的基本运算">关系代数的基本运算</a> »
                        </span>
                        
                    </p>
                </footer>
            </article>
            <section>
    <h2>Comments</h2>
    <div id="disqus_thread"></div>
    <script>
    (function() {
    var d = document, s = d.createElement('script');
    s.src = '//keelii-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>


        </div>

        <aside class="sidebar">
    
        
<section id="side-toc" class="side-toc odd toggle">
    <h2><span>Table  of contents</span> <span class="close-toc" onclick="document.querySelector(&#39;#side-toc&#39;).classList.add(&#39;toggle&#39;)">×</span></h2>
    <nav id="TableOfContents">
<ul>
<li><a href="https://keelii.com/2016/12/22/sku-multi-dimensional-attributes-state-algorithm/#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0">问题描述</a></li>
<li><a href="https://keelii.com/2016/12/22/sku-multi-dimensional-attributes-state-algorithm/#%E7%A1%AE%E5%AE%9A%E8%A7%84%E5%88%99">确定规则</a></li>
<li><a href="https://keelii.com/2016/12/22/sku-multi-dimensional-attributes-state-algorithm/#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95">解决方法</a>
<ul>
<li><a href="https://keelii.com/2016/12/22/sku-multi-dimensional-attributes-state-algorithm/#%E7%BC%A9%E5%B0%8F%E9%97%AE%E9%A2%98%E8%A7%84%E6%A8%A1">缩小问题规模</a></li>
<li><a href="https://keelii.com/2016/12/22/sku-multi-dimensional-attributes-state-algorithm/#%E8%B0%83%E6%95%B4%E6%80%9D%E8%B7%AF">调整思路</a></li>
<li><a href="https://keelii.com/2016/12/22/sku-multi-dimensional-attributes-state-algorithm/#%E4%BC%98%E5%8C%96%E4%BD%93%E9%AA%8C">优化体验</a></li>
</ul></li>
<li><a href="https://keelii.com/2016/12/22/sku-multi-dimensional-attributes-state-algorithm/#%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6">算法复杂度</a></li>
</ul>
</nav>
    <div class="fold" onclick="document.querySelector(&#39;#side-toc&#39;).classList.toggle(&#39;toggle&#39;)">§</div>

</section>
<script>
document.onclick = function() {
    document.querySelector('#side-toc').classList.add('toggle')
}
document.querySelector('#side-toc').onclick = function(e) {
    e.stopPropagation()
}
</script>



    
</aside>

    </div>
</div>

<footer id="footer" role="contentinfo">
    <p>
        Copyright © 2020 keelii
    </p>
</footer>

</div>

<script>

(function(window, document) {
    window.changeFont = function() {
        var el = document.getElementById('font-family')
        var font = localStorage.getItem('fontFamily')
        
        document.querySelectorAll('.typo').forEach(node => {
            node.classList.remove('sans-serif', 'serif')
            node.classList.add(font)
        })
        if (el) el.checked = font === 'sans-serif'
    }
    changeFont()
})(window, document); 
</script>





<script src="./Sku 多维属性状态判断算法_files/highlight.pack.js.下载"></script>
<script>
if (typeof hljs !=="undefined") hljs.initHighlightingOnLoad()
</script>



<script>
!function(e){function t(e){for(var t=location.href,n=t.split("").reverse(),r=e.split(""),i=[],s=0,o=16;o>s;s++)i.push(r[s]+(n[s]||""));return i.join("")}var n=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.so\.com)/gi,r=e.location.href;if(r&&!n.test(r)&&window.navigator.appName){var i="//s.360.cn/so/zz.gif",o="0cbb5a2bef902d89e9dc9bb5f742b91c",u=t(o),a=new Image;r&&(i+="?url="+encodeURIComponent(r)),o&&(i+="&sid="+o),u&&(i+="&token="+u),o&&(a.src=i)}}(window);
</script>



<iframe id="blockbyte-bs-sidebar" class="notranslate" data-pos="right" src="./Sku 多维属性状态判断算法_files/saved_resource.html"></iframe><div id="blockbyte-bs-indicator" class="blockbyte-bs-fullHeight" style="width: 2px; height: 100%; top: 0%;"></div></body></html>